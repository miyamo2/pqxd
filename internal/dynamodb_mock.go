// Code generated by MockGen. DO NOT EDIT.
// Source: dynamodb.go
//
// Generated by this command:
//
//	mockgen -source=dynamodb.go --package=internal -destination=./internal/dynamodb_mock.go
//

// Package internal is a generated GoMock package.
package internal

import (
	context "context"
	reflect "reflect"

	dynamodb "github.com/aws/aws-sdk-go-v2/service/dynamodb"
	gomock "go.uber.org/mock/gomock"
)

// MockDynamoDBClient is a mock of DynamoDBClient interface.
type MockDynamoDBClient struct {
	ctrl     *gomock.Controller
	recorder *MockDynamoDBClientMockRecorder
	isgomock struct{}
}

// MockDynamoDBClientMockRecorder is the mock recorder for MockDynamoDBClient.
type MockDynamoDBClientMockRecorder struct {
	mock *MockDynamoDBClient
}

// NewMockDynamoDBClient creates a new mock instance.
func NewMockDynamoDBClient(ctrl *gomock.Controller) *MockDynamoDBClient {
	mock := &MockDynamoDBClient{ctrl: ctrl}
	mock.recorder = &MockDynamoDBClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDynamoDBClient) EXPECT() *MockDynamoDBClientMockRecorder {
	return m.recorder
}

// BatchExecuteStatement mocks base method.
func (m *MockDynamoDBClient) BatchExecuteStatement(ctx context.Context, params *dynamodb.BatchExecuteStatementInput, optFns ...func(*dynamodb.Options)) (*dynamodb.BatchExecuteStatementOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "BatchExecuteStatement", varargs...)
	ret0, _ := ret[0].(*dynamodb.BatchExecuteStatementOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BatchExecuteStatement indicates an expected call of BatchExecuteStatement.
func (mr *MockDynamoDBClientMockRecorder) BatchExecuteStatement(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchExecuteStatement", reflect.TypeOf((*MockDynamoDBClient)(nil).BatchExecuteStatement), varargs...)
}

// CreateTable mocks base method.
func (m *MockDynamoDBClient) CreateTable(ctx context.Context, params *dynamodb.CreateTableInput, optFns ...func(*dynamodb.Options)) (*dynamodb.CreateTableOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateTable", varargs...)
	ret0, _ := ret[0].(*dynamodb.CreateTableOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateTable indicates an expected call of CreateTable.
func (mr *MockDynamoDBClientMockRecorder) CreateTable(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTable", reflect.TypeOf((*MockDynamoDBClient)(nil).CreateTable), varargs...)
}

// DeleteTable mocks base method.
func (m *MockDynamoDBClient) DeleteTable(ctx context.Context, params *dynamodb.DeleteTableInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteTableOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteTable", varargs...)
	ret0, _ := ret[0].(*dynamodb.DeleteTableOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteTable indicates an expected call of DeleteTable.
func (mr *MockDynamoDBClientMockRecorder) DeleteTable(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTable", reflect.TypeOf((*MockDynamoDBClient)(nil).DeleteTable), varargs...)
}

// DescribeTable mocks base method.
func (m *MockDynamoDBClient) DescribeTable(ctx context.Context, params *dynamodb.DescribeTableInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DescribeTableOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DescribeTable", varargs...)
	ret0, _ := ret[0].(*dynamodb.DescribeTableOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DescribeTable indicates an expected call of DescribeTable.
func (mr *MockDynamoDBClientMockRecorder) DescribeTable(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeTable", reflect.TypeOf((*MockDynamoDBClient)(nil).DescribeTable), varargs...)
}

// ExecuteStatement mocks base method.
func (m *MockDynamoDBClient) ExecuteStatement(ctx context.Context, params *dynamodb.ExecuteStatementInput, optFns ...func(*dynamodb.Options)) (*dynamodb.ExecuteStatementOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteStatement", varargs...)
	ret0, _ := ret[0].(*dynamodb.ExecuteStatementOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteStatement indicates an expected call of ExecuteStatement.
func (mr *MockDynamoDBClientMockRecorder) ExecuteStatement(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteStatement", reflect.TypeOf((*MockDynamoDBClient)(nil).ExecuteStatement), varargs...)
}

// ExecuteTransaction mocks base method.
func (m *MockDynamoDBClient) ExecuteTransaction(ctx context.Context, params *dynamodb.ExecuteTransactionInput, optFns ...func(*dynamodb.Options)) (*dynamodb.ExecuteTransactionOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ExecuteTransaction", varargs...)
	ret0, _ := ret[0].(*dynamodb.ExecuteTransactionOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecuteTransaction indicates an expected call of ExecuteTransaction.
func (mr *MockDynamoDBClientMockRecorder) ExecuteTransaction(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteTransaction", reflect.TypeOf((*MockDynamoDBClient)(nil).ExecuteTransaction), varargs...)
}

// ListTables mocks base method.
func (m *MockDynamoDBClient) ListTables(ctx context.Context, params *dynamodb.ListTablesInput, optFns ...func(*dynamodb.Options)) (*dynamodb.ListTablesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListTables", varargs...)
	ret0, _ := ret[0].(*dynamodb.ListTablesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTables indicates an expected call of ListTables.
func (mr *MockDynamoDBClientMockRecorder) ListTables(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTables", reflect.TypeOf((*MockDynamoDBClient)(nil).ListTables), varargs...)
}

// UpdateTable mocks base method.
func (m *MockDynamoDBClient) UpdateTable(ctx context.Context, params *dynamodb.UpdateTableInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateTableOutput, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, params}
	for _, a := range optFns {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateTable", varargs...)
	ret0, _ := ret[0].(*dynamodb.UpdateTableOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateTable indicates an expected call of UpdateTable.
func (mr *MockDynamoDBClientMockRecorder) UpdateTable(ctx, params any, optFns ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, params}, optFns...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTable", reflect.TypeOf((*MockDynamoDBClient)(nil).UpdateTable), varargs...)
}
